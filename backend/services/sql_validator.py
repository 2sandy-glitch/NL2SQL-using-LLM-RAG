"""
SQL Guardrails & Validation Module
Secure validator for NL2SQL LLM-generated queries.
"""

import re
from typing import Tuple


# ===============================
# Configuration
# ===============================

#  Allowed tables (Whitelist)
ALLOWED_TABLES = ["customers", "orders", "products"]

#  Disallowed destructive keywords
DISALLOWED_KEYWORDS = [
    "INSERT",
    "UPDATE",
    "DELETE",
    "DROP",
    "ALTER",
    "TRUNCATE",
    "CREATE",
    "REPLACE",
    "GRANT",
    "REVOKE",
    "EXEC",
    "CALL"
]

#  Block system schemas
DISALLOWED_SCHEMAS = [
    "information_schema",
    "pg_catalog",
    "mysql",
    "sys"
]

#  Query constraints
MAX_QUERY_LENGTH = 1000
DEFAULT_LIMIT = 100
MAX_LIMIT = 500


# ===============================
# Main Validator
# ===============================

def validate_and_secure_sql(sql: str) -> Tuple[bool, str, str]:
    """
    Validates and secures SQL query generated by LLM.

    Returns:
        (is_valid: bool, message: str, secured_sql: str)
    """

    if not sql:
        return False, "Empty SQL query.", ""

    sql_clean = sql.strip()
    sql_upper = sql_clean.upper()

    # -------------------------------
    #  Query Length Check
    # -------------------------------
    if len(sql_clean) > MAX_QUERY_LENGTH:
        return False, "Query too long.", ""

    # -------------------------------
    #  Only SELECT Allowed
    # -------------------------------
    if not sql_upper.startswith("SELECT"):
        return False, "Only SELECT queries are allowed.", ""

    # -------------------------------
    #  Prevent Multiple Statements
    # -------------------------------
    if ";" in sql_clean[:-1]:
        return False, "Multiple SQL statements are not allowed.", ""

    # -------------------------------
    #  Block Destructive Keywords
    # -------------------------------
    for keyword in DISALLOWED_KEYWORDS:
        if re.search(rf"\b{keyword}\b", sql_upper):
            return False, f"Usage of '{keyword}' is not allowed.", ""

    # -------------------------------
    #  Block System Schema Access
    # -------------------------------
    for schema in DISALLOWED_SCHEMAS:
        if schema.upper() in sql_upper:
            return False, "Access to system schemas is not allowed.", ""

    # -------------------------------
    #  Block SQL Comments (Injection)
    # -------------------------------
    if "--" in sql_upper or "/*" in sql_upper:
        return False, "SQL comments are not allowed.", ""

    # -------------------------------
    # 7 Restrict Allowed Tables
    # -------------------------------
    tables_in_query = re.findall(r"\bFROM\s+([a-zA-Z0-9_]+)", sql_upper)
    tables_in_query += re.findall(r"\bJOIN\s+([a-zA-Z0-9_]+)", sql_upper)

    for table in tables_in_query:
        if table.lower() not in ALLOWED_TABLES:
            return False, f"Access to table '{table}' is not allowed.", ""

    # -------------------------------
    #  Enforce / Inject LIMIT
    # -------------------------------
    secured_sql = enforce_limit(sql_clean)

    return True, "Query is valid and secured.", secured_sql


# ===============================
# LIMIT Enforcement Logic
# ===============================

def enforce_limit(sql: str) -> str:
    """
    Ensures query has a LIMIT clause.
    If missing -> inject DEFAULT_LIMIT
    If LIMIT > MAX_LIMIT -> cap it
    """

    sql_upper = sql.upper()

    # If LIMIT exists, validate it
    limit_match = re.search(r"\bLIMIT\s+(\d+)", sql_upper)

    if limit_match:
        limit_value = int(limit_match.group(1))

        if limit_value > MAX_LIMIT:
            # Cap limit
            sql = re.sub(
                r"\bLIMIT\s+\d+",
                f"LIMIT {MAX_LIMIT}",
                sql,
                flags=re.IGNORECASE
            )
        return sql

    # If LIMIT missing â†’ Inject
    return f"{sql.rstrip(';')} LIMIT {DEFAULT_LIMIT}"